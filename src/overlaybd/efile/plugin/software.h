#ifndef __SOFTWARE_H__
#define __SOFTWARE_H__

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
//#include <memory>
// #include <sys/types.h>
// #include <unistd.h>

typedef unsigned char Cpa8U;
typedef unsigned long int Cpa32U;
typedef void * KeyHandle;
typedef void * CpaInstanceHandle;

/* Unsigned 64 bit integer */
typedef uint64_t i64_t;

/* Unsigned 32 bit integer */
//typedef uint32_t i32_t;

/* Unsigned 16 bit integer */
typedef uint16_t i16_t;

/* Unsigned 8 bit integer */
typedef uint8_t i8_t;

typedef struct _CpaFlatBuffer {
    Cpa32U dataLenInBytes;
    /**< Data length specified in bytes.
     * When used as an input parameter to a function, the length specifies
     * the current length of the buffer.
     * When used as an output parameter to a function, the length passed in
     * specifies the maximum length of the buffer on return (i.e. the allocated
     * length).  The implementation will not write past this length.  On return,
     * the length is always unchanged. */
  Cpa8U *pData;
    /**< The data pointer is a virtual address, however the actual data pointed
     * to is required to be in contiguous physical memory unless the field
     requiresPhysicallyContiguousMemory in CpaInstanceInfo2 is false. */
} CpaFlatBuffer;

typedef struct _CpaCyAesPublicKey {
    CpaFlatBuffer modulusN;
    /**< The modulus (n).
     * For key generation operations, the client MUST allocate the memory
     * for this parameter; its value is generated.
     * For encrypt operations this parameter is an input. */
    CpaFlatBuffer publicExponentE;
    /**< The public exponent (e).
     * For key generation operations, this field is unused.  It is NOT
     * generated by the interface; it is the responsibility of the client
     * to set this to the same value as the corresponding parameter on
     * the CpaCyRsaKeyGenOpData structure before using the key for
     * encryption.
     * For encrypt operations this parameter is an input. */
} CpaCyAesPublicKey;

typedef enum CpaCyKptWrappingKeyType_t {
    CPA_CY_KPT_WRAPPING_KEY_TYPE_AES256_GCM = 0
} CpaCyKptWrappingKeyType;

typedef struct CpaCyLoadKey_t {
    CpaFlatBuffer             eSWK;
    /**< Encrypted SWK */
    CpaCyKptWrappingKeyType   wrappingAlgorithm;
    /**< Symmetric wrapping algorithm*/
} CpaCyLoadKey;

namespace EFile {

typedef struct _AESKey {
    char *puk_lek;
} AESKey;

/* SoftwareOptions will write into file */
class SoftwareOptions {
public:
    const static uint8_t AES = 0;
    const static uint8_t BlowFish = 1;
    const static uint8_t Others = 2;
    const static uint32_t DEFAULT_BLOCK_SIZE = 4096; // 8192;//32768;
    uint32_t block_size = DEFAULT_BLOCK_SIZE;
    uint8_t type;
    char *prk;

    SoftwareOptions(uint8_t type = AES, uint32_t block_size = DEFAULT_BLOCK_SIZE)
        : block_size(block_size), type(type) {
    }
};

class SoftwareArgs {
public:
    char *prk;
    SoftwareOptions opt;

    SoftwareArgs(const SoftwareOptions &opt)
        : opt(opt) {
    };
};

class ISoftware {
public:
    virtual ~ISoftware(){};
                       
    /*
     * puk_lek: user key
     * hk: key handle
     * 
     *  success return 0.
        return -1 when error occurred.
    */
    virtual int loadKey(char *puk_lek, KeyHandle *hk) = 0;

    /*
     * input param
     *   hk: key handle, we can get key by this key handle
     *   cipher: cipher text
     *   plain: plain text
     *   clen: cipher text len
     *   plen: plain text len
     * output param
     *   return encrypted buffer size.
     *   return -1 when error occurred.
    */
    virtual int encrypt(KeyHandle hk,
                        const unsigned char *src,
                        size_t src_len,
                        unsigned char *dst,
                        size_t dst_len) = 0;

    /*
     * input param
     *   hk: key handle, we can get key by this key handle
     *   cipher: cipher text
     *   plain: plain text
     *   clen: cipher text len
     *   plen: plain text len
     * output param
     *   return decrypted buffer size.
     *   return -1 when error occurred.
    */
    virtual int decrypt(KeyHandle hk,
                        const unsigned char *src,
                        size_t src_len,
                        unsigned char *dst,
                        size_t dst_len) = 0;
};

extern "C" ISoftware *create_software(const SoftwareArgs *args);
} // namespace EFile

#endif
